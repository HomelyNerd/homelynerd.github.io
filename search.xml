<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基础（数组基本概念、数组引用传递、数组静态初始化、二维数组）]]></title>
    <url>%2F2018%2F06%2F24%2FJava%E5%9F%BA%E7%A1%80%EF%BC%88%E6%95%B0%E7%BB%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E3%80%81%E6%95%B0%E7%BB%84%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数组基本概念如果要求定义一百个整型变量，传统定义方法将非常麻烦（int i1，int i2……）。 数组的定义数组：一组相关类型的变量集合，且这些变量可以按照统一的方式操作，属于引用数据类型，因此又牵扯到内存分配。定义语法： 数组动态初始化声明并开辟数组 - 数据类型 数组名称[] = new 数据类型[长度]（或数据类型[] 数组名称 = new 数据类型[长度]） 分步进行数组空间的开辟（实例化）声明数组 - 数据类型 数组名称[] = null;（或数据类型[] 数组名称 = null;）开辟数组空间 - 数组名称 = new 数据类型; 当数组开辟空间后，即可采用以下方式进行操作数组的访问通过索引完成，即“数组名称[索引]”，但需要注意的是数组的索引从0开始，索引范围是0到数组长度-1；当数组采用动态初始化开辟空间之后，数组中每一个元素都是该数组对应数据类型的默认值，如果数组访问时超过了数组索引范围，则会产生越界异常-ArrayIndexOutOfBoundsException；数组本身是一个有序的集合操作，数组的内容操作往往会通过循环完成，数组是一个有限的数据集合，因此使用for循环； Java中有一种动态取得数组长度的方式：数组名称.length。 范例：定义一个整型（int）数组12345678910111213141516public class Hello&#123;//动态初始化 public static void main(String args[])&#123; int data[] = new int[3]; //System.out.println(data.length); data[0] = 10; data[1] = 20; data[2] = 30;//数组各元素赋值 // System.out.println(data[0]);//10 // System.out.println(data[1]);//20 // System.out.println(data[2]);//30 // System.out.println(data[3]);//报错，数组越界异常 for(int x = 0; x &lt; data.length; x++)&#123; System.out.println(data[x]); &#125; &#125;&#125; 分步开辟数组空间1234567891011public class Hello&#123; public static void main(String args[])&#123; int data[] = null; //data = new int[3];//分步 // 千万要记住，数组属于引用数据类型，因此在使用之前一定要开辟空间（实例化） // 这一原则与对象操作完全相同 // 使用未开辟空间的数组会出现NullPointerException异常信息 System.out.println(data.length);//报错 &#125;&#125; 数组引用传递数组本身也属于引用数据类型，因此也可以发生引用传递，而引用传递的本质是：同一块堆内存空间可以被不同的栈内存所指向。 开辟数组空间123456789public class Hello&#123; public static void main(String args[])&#123; int data[] = null; data = new int[3]; data[0] = 10; data[1] = 20; data[2] = 30; &#125;&#125; 内存示意图：数组引用传递1 引用传递12345678910111213141516public class Hello&#123; public static void main(String args[])&#123; int data[] = null; int temp[] = null; data = new int[3]; //temp = data;//提前进行引用传递也可达到一样的效果 data[0] = 10; data[1] = 20; data[2] = 30; temp = data;//如果要发生引用传递，不能出现[] temp[0] = 99;//修改数据 for(int x = 0; x &lt; data.length; x++)&#123; System.out.println(data[x]);//99 20 30 &#125; &#125;&#125; 内存示意图：数组引用传递2 数组静态初始化之前的数组定义都有一个明显特点：数组先开辟内存空间，再使用索引进行内容的设置，这种做法统称动态初始化。如果希望数组在定义的时候同时设置内容，则可使用静态初始化完成。数组的静态初始化语法分为两种：（建议使用第二种） 简化格式：数据类型 数组名称[] = {值, 值...}; 完整格式：数据类型 数组名称[] = new 数据类型[] {值,值...}; 范例：采用静态初始化(简化格式)定义数组123456789101112131415public class Hello&#123; public static void main(String args[])&#123; int data[] = &#123;1, 2, 34, 98, 987, 90, 82, 139, 68, 52&#125;;//不用再逐一给数组赋值 for(int i = 0; i &lt; data.length; i++)&#123; System.out.println(data[x]); &#125; &#125;&#125;//在开发过程中强烈建议使用完整格式，这样就可以轻松使用匿名数组这一概念public class Hello&#123; public static void main(String args[])&#123; //System.out.println(&#123;1, 2, 34, 98, 987, 90, 82, 139, 68, 52&#125;.length);//报错 System.out.println(new int[] &#123;1, 2, 34, 98, 987, 90, 82, 139, 68, 52&#125;.length);//10 &#125;&#125; 以后使用静态方式定义数组一定要使用完整格式，数组最大的缺陷：长度固定。 二维数组动态初始化：1数据类型 对象数组[][] = new 数据类型[行数][列数]; 静态初始化：1数据类型 对象数组[][] = new 数据类型[][]&#123;&#123;值, 值&#125;,&#123;值, 值&#125;,&#123;值, 值&#125;,&#123;值, 值&#125;...&#125;; 范例：定义一个二维数组123456789101112public class Hello&#123; public static void main(String args[])&#123; int data[][] = new int[][]&#123; &#123;1,2,3&#125;, &#123;4,5&#125;, &#123;6,7,8,9&#125;&#125;; for(int i = 0; i &lt; data.length; i++)&#123; for(int j = 0; j &lt; data[i].length; j++)&#123; System.out.print("data[" + i + "][" + j + "]= " + data[i][j]+" "); &#125; System.out.println(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（构造方法、匿名对象、简单Java类）]]></title>
    <url>%2F2018%2F06%2F23%2FJava%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E3%80%81%E7%AE%80%E5%8D%95Java%E7%B1%BB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[构造方法与匿名对象构造方法实例化对象的格式：类名称 对象名称 = new 类名称();观察组成部分: 类名称 - 任何对象都应该有其对应的类，因为没有类就不知道对象具备的功能； 对象名称 - 一个唯一的标记，便于以后操作属性； new - 开辟新的堆内存空间； 类名称() - 构造方法。 所谓“构造方法”就是使用关键字new实例化新对象的时候来进行调用的操作方法，但对于构造方法定义也需要遵循如下原则： 方法名称需与类名称相同； 构造方法没有返回值类型声明； 每一个类中至少存在一个构造方法，如果类中没有明确定义任何构造方法，将自动生成一个无参数的、什么都不做的构造方法； 范例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Person&#123; private String name; private int age; //构造方法名称与类名称相同，并且没有返回值类型声明 public Person()&#123; System.out.println("***********"); &#125; //如果在现在的类中不写此定义，也会在编译后自动生成 public void setName(String n)&#123; name = n; &#125; public void setAge(int a)&#123; if(a &gt;= 0 &amp;&amp; a &lt;= 150)&#123; age = a; &#125;else&#123; age = 0; &#125; &#125; public String getName()&#123; return name; &#125; public int getAge()&#123; return age; &#125; //不管getter、setter有没有被使用到，必须都提供 public void info()&#123; System.out.println("name = " + name + ",\n" + "age = " + age + "."); &#125; //封装后类内部的操作不受影响 &#125;public class Hello&#123; public static void main(String args[])&#123; Person per = new Person(); //会先生成“***********”，因为在使用关键字new的时候才调用构造方法,一个对象只能使用new一次，即只能构造一次 per.setName("Weo"); per.setAge(10); per.info(); &#125;&#125; 疑问：既然构造方法中没有返回数据，为什么不在返回值类型声明时声明成void？现在类中的组成：属性、普通方法、构造方法 属性 - 对象开辟堆内存的时候就开辟的空间； 构造方法 - 是在使用关键字new同时调用的；public Person(); 普通方法 - 对象已经实例化（空间开辟了，构造方法执行了）再调用的，可调用多次；public void Person()， 命名不标准但无语法错误； 因此构造方法不能声明成void类型，类中可以自动生成的无参构造方法实际上是有一个前提的：类中没有定义任何构造方法。相反如果类中已经定义了一个构造方法，那么此类中默认的构造方法将不会自动生成。范例：类中定义一个有参构造方法1234567891011121314151617181920212223242526272829303132333435363738394041424344class Person&#123; private String name; private int age; //构造方法名称与类名称相同，并且没有返回值类型声明 public Person(String n, int a)&#123; name = n; setAge(a); &#125; public void setName(String n)&#123; name = n; &#125; public void setAge(int a)&#123; if(a &gt;= 0 &amp;&amp; a &lt;= 150)&#123; age = a; &#125;else&#123; age = 0; &#125; &#125; public String getName()&#123; return name; &#125; public int getAge()&#123; return age; &#125; public void info()&#123; System.out.println("name = " + name + ",\n" + "age = " + age + "."); &#125;&#125; public class Hello&#123; public static void main(String args[])&#123; //Person per = new Person();//报错，需要先把参数传上去 Person per = new Person("Weo", 18); per.setAge(23);//利用setter修改属性 // per.setName("Weo"); // per.setAge(10); per.info(); &#125;&#125; 构造方法的作用： 构造方法的调用与对象内存分配几乎是同时完成的，因此可以利用构造方法设置类中的属性内容，即对类中的属性进行初始化处理； 通过构造方法设置内容，实际上可以避免重复的setter调用（如一个类有20个属性，则需要调用20次setter方法…）。 那这么一来setter不就没用了么？不，实际的开发过程中setter方法除了具备设置内容的功能，还可以用来修改数据。既然构造方法本身属于方法，那么一定可以重载，构造方法的重载更加简单，因为方法名称就是类名称，能够做的只是实现参数的类型或个数不同这一功能。 范例：构造方法的重载1234567891011121314151617181920212223242526272829303132333435363738394041424344class Person&#123; private String name; private int age; public Person(String n, int a)&#123; name = n; setAge(a); &#125; public Person(String n)&#123;//构造方法的重载 name = n; &#125; public Person()&#123;&#125;//构造方法的重载 public void setName(String n)&#123; name = n; &#125; public void setAge(int a)&#123; if(a &gt;= 0 &amp;&amp; a &lt;= 150)&#123; age = a; &#125;else&#123; age = 0; &#125; &#125; public String getName()&#123; return name; &#125; public int getAge()&#123; return age; &#125; public void info()&#123; System.out.println("name = " + name + ",\n" + "age = " + age + "."); &#125;&#125;public class Hello&#123; public static void main(String args[])&#123; Person per = new Person("Weo"); per.setAge(23); per.info(); &#125;&#125; 在构造方法重载的时候需要注意定义结构，建议若干个构造方法按照参数个数，升序或降序排列，同时也需要注意一点，在进行类定义时，按如下顺序完成： 属性 构造方法 普通方法 匿名对象构造方法可以传递属性内容，那么很多时候为了使用方便，往往会采用匿名对象。范例：匿名对象123456789101112131415161718192021222324252627282930313233343536class Person&#123; private String name; private int age; public Person(String n, int a)&#123; name = n; setAge(a); &#125; public void setName(String n)&#123; name = n; &#125; public void setAge(int a)&#123; if(a &gt;= 0 &amp;&amp; a &lt;= 150)&#123; age = a; &#125;else&#123; age = 0; &#125; &#125; public String getName()&#123; return name; &#125; public int getAge()&#123; return age; &#125; public void info()&#123; System.out.println("name = " + name + ",\n" + "age = " + age + "."); &#125;&#125;public class Hello&#123; public static void main(String args[])&#123; new Person("Weo", 23).info(); //匿名对象 &#125;&#125; 由于匿名空间不会有任何栈空间所指向，所以使用一次之后就将成为垃圾，是否使用匿名对象没有绝对的定论。 总结： 每个类中至少存在一个构造方法； 构造方法的名称与类名称相同； 构造方法允许重载，重载时只需考虑参数的类型与个数即可。 简单Java类例如：定义一个雇员类，类中包括雇员编号、姓名、职位、基本工资、佣金几个属性信息，这种类称为简单Java类，有其明确的开发要求： 类的名称有意义，可以明确地描述出某类事物，例如 - Emp、Member等； 类中所有属性必须使用private封装，所有属性必须按照要求提供setter与getter方法； 类中可以定义若干个构造方法，但必须保留有一个无参构造方法； 类中的所有方法都不允许出现任何System.out语句，所有输出必须交给调用处来完成； 类中应该提供有一个返回类完整信息的方法，这个方法名称暂为getInfo(); 范例：编写一个简单Java类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Emp&#123;//类名称可以明确描述某一事物 private int empno; private String ename; private String epos; private double sal; private double comm; public Emp()&#123;&#125; //无参构造方法，可以没有 public Emp(int eno, String ena, String ps, double sl, double cm)&#123; setEmpno(eno); setEname(ena); setEpos(ps); setSal(sl); setComm(cm); &#125; public void setEmpno(int eno)&#123; empno = eno; &#125; public void setEname(String ena)&#123; ename = ena; &#125; public void setEpos(String ps)&#123; epos = ps; &#125; public void setSal(double sl)&#123; sal = sl; &#125; public void setComm(double cm)&#123; comm = cm; &#125; public int getEmpno()&#123; return empno; &#125; public String getEname()&#123; return ename; &#125; public String getEpos()&#123; return epos; &#125; public double getSal()&#123; return sal; &#125; public double getComm()&#123; return comm; &#125; public String getInfo()&#123; return "Employee's number: " + empno + "\n" + "Employee's name: " + ename + "\n" + "Employee's position: " + epos + "\n" + "Employee's salary: " + sal + "\n" + "Employee's commission: " + comm + "\n" ; &#125;&#125;public class Hello&#123; public static void main(String args[])&#123; // 范例：简单Java类测试程序 System.out.println(new Emp(170711205, "Weo Wang", "Hardware Engineer", 5500.0, 1100.0).getInfo()); &#125;&#125;]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（面向对象、对象内存分析、引用传递简析、封装）]]></title>
    <url>%2F2018%2F06%2F20%2FJava%E5%9F%BA%E7%A1%80%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%AE%80%E6%9E%90%E3%80%81%E5%B0%81%E8%A3%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[面向对象的三个特点： 封装性 - 内部操作对外部不可见； 继承性 - 再上一辈的基础上继续发展； 多态性 - 最为重要的环节，利用多态性才可以得到良好的设计。 三种编程模式： OOA - 面向对象分析 OOD - 面向对象设计 OOP - 面向对象编程 类与对象的定义与使用类与对象：面向对象设计的核心类，引用数据类型，使用上会牵扯到内存分配的问题。 类中的组成：方法（操作的行为）、属性（变量、描述每一个对象的基本特点） 类的定义：class关键字语法：12345class 类名称&#123; 属性 方法()&#123;//不由主类直接调用，而是通过对象进行调用 &#125;&#125; 定义一个简单的类1234567class Person&#123; //定义一个简单的类 String name;//属性 int age;//属性 public void info()&#123;//方法 System.out.println("name: " + name + ",\n" + "age = " + age + "."); &#125;&#125; 类的使用类定义后不能直接使用，要使用必须先产生对象，而对象的定义由两种语法形式： 声明并实例化对象：类名称 对象名称 = new 类名称(); 分步进行对象实例化：声明对象：类名称 对象名称 = null;实例化对象：对象名称 = new 类名称(); new：开辟新内存（内存不可能无限开辟，性能调优调整的就是内存问题）。 对象的使用： 调用类中的属性：对象.属性 = 内容; 调用类中的方法：对象.方法(); 声明并实例化对象12345678public class Hello&#123; public static void main(String args[])&#123; Person per = new Person(); per.name = "Weo";//设置对象中的属性 per.age = 18;//设置对象中的属性 per.info();//调用对象中的方法 &#125;&#125; 对象内存分析引用类型：内存空间的操作主要使用的内存空间： 堆内存空间 - 保存真正的数据，堆内存保存的是对象的属性信息 栈内存空间 - 保存的对内存的地址，即堆内存的操作权，可以理解为保存的是对象名称 12345678910111213141516class Person&#123; String name; int age; public void info()&#123; System.out.println("name = " + name + ",\n" + "age = " + age + "."); &#125;&#125;public class Hello&#123; public static void main(String args[])&#123; Person per = new Person(); per.name = "Weo"; per.age = 18; per.info(); &#125;&#125; 对应示意图：对象的内存分析 以上方法是声明并实例化对象的格式，也可以分步进行:1234567891011121314151617class Person&#123; String name; int age; public void info()&#123; System.out.println("name = " + name + ",\n" + "age = " + age + "."); &#125;&#125;public class Hello&#123; public static void main(String args[])&#123; Person per = null; per = new Person(); per.name = "Weo"; per.age = 18; per.info(); &#125;&#125; 对应示意图：对象的内存分析 要记住一点，对象（所有引用数据类型）必须在其开辟内存空间之后方可使用，使用了未开辟内存空间的引用和数据类型，将出现NullPointerException: 1234567891011121314class Person&#123; String name; int age; public void info()&#123; System.out.println("name = " + name + ",\n" + "age = " + age + "."); &#125;&#125;public class Hello&#123; public static void main(String args[])&#123; Person per = null; //仅声明，未实例化对象，未为其开辟堆内存空间，程序编译时不会报错（即没有语法错误） per.info(); //报错：Exception in thread "main" java.lang.NullPointerException at Hello.main(Hello.java:951) &#125;&#125; NullPointerException：常见异常，仅引用数据类型才出现此类异常。 引用传递引用传递分析引用的本质在于别名，而这个别名放在了栈内存中，一块堆内存可以被多块栈内存所指向。 12345678910111213141516171819class Person&#123; String name; int age; public void info()&#123; System.out.println("name = " + name + ",\n" + "age = " + age + "."); &#125;&#125;public class Hello&#123; public static void main(String args[])&#123; Person per1 = new Person(); per1.name = "Weo"; per1.age = 18; //以下步骤就是引用传递 Person per2 = per1; //采用同样的类型接收 per2.name = "汪威佑"; per1.info(); &#125;&#125; 对应示意图：引用传递分析1 123456789101112131415161718192021class Person&#123; String name; int age; public void info()&#123; System.out.println("name = " + name + ",\n" + "age = " + age + "."); &#125;&#125;public class Hello&#123; public static void main(String args[])&#123; Person per1 = new Person(); Person per2 = new Person(); per1.name = "Weo"; per1.age = 18; per2.name = "汪威佑"; per2.age = 22; per2 = per1; per2.name = "帅哥"; per1.info(); &#125;&#125; 对应示意图： 引用传递分析2 垃圾内存空间没有任何栈内存指向的堆内存，所有垃圾空间将不定期被Java中的垃圾收集器（GC）回收，以实现内存空间的释放，虽然Java提供有GC，但GC也会影响程序性能，因此开发过程中一定要控制好对象的产生数量，无用的对象尽量少产生（使用了new一定会产生新的堆内存空间）。 封装封装简析一旦属性的声明使用了private定义，如果其他类直接访问该属性时，将报错。12345678910111213141516class Person&#123; private String name; private int age; //一旦属性的声明使用了private定义，如果其他类直接访问该属性时，将报错 public void info()&#123; System.out.println("name = " + name + ",\n" + "age = " + age + "."); &#125;&#125;public class Hello&#123; public static void main(String args[])&#123; Person per = new Person(); per.name = "Weo"; per.age = 20; per.info(); &#125;&#125; 没封装时，若年龄被赋值-200，显然是不对的，业务逻辑出错。如果要解决这个问题，应该让对象不能直接操作年龄的属性，或者说让类的外部不能操作内部的敏感内容，所以解决问题的核心观念是如何让内部操作对外部不可见，即可以通过private关键字实现（类中的属性和方法中都可以使用private，但在方法中使用很少）。使用private声明后，属性安全了，外部无法直接操作，要想进行private私有属性的访问，按照Java设计原则，可使用setter与getter方法 setter：用于属性内容的设置 -private String name: public void setName(String n); getter：用于属性内容的取得 -private String name: public String getName(); 12345678910111213141516171819202122232425262728293031323334353637383940class Person&#123; private String name; private int age; public void setName(String n)&#123; name = n; &#125; public void setAge(int a)&#123; if(a &gt;= 0 &amp;&amp; a &lt;= 150)&#123; age = a; &#125;else&#123; age = 0; &#125; &#125; public String getName()&#123; return name; &#125; public int getAge()&#123; return age; &#125; //不管getter、setter有没有被使用到，必须都提供 public void info()&#123; System.out.println("name = " + name + ",\n" + "age = " + age + "."); &#125; //封装后类内部的操作不受影响&#125;public class Hello&#123; public static void main(String args[])&#123; Person per = new Person(); per.setName("Weo"); per.setAge(10); per.info(); &#125;&#125; 此时业务逻辑的检测可以在setter中完成。 类的使用原则以后在创建类的过程中所有属性必须使用private封装，使用private封装的属性如果需要被外部所使用，需按照格式定义相应的setter或getter方法。 private实现封装的最大特征：只允许本类访问，而不允许外部访问。private只是封装的第一步，后续还要弄懂继承和多态，才能弄懂封装。]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（顺序、分支与循环结构）]]></title>
    <url>%2F2018%2F06%2F18%2FJava%E5%9F%BA%E7%A1%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E3%80%81%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介程序执行的三种类型：顺序结构、分支结构与循环结构。 顺序结构代码按照定义顺序一行一行执行。 分支结构进行逻辑判断，当满足某些条件时才会执行某些语句。 if分支结构格式：1234567if(布尔表达式)&#123; 条件满足时执行的代码;&#125;else if&#123; 条件不满足时执行的代码;&#125;else&#123; 所有条件都不满足时执行的代码;&#125; 12345678910111213public class Demo&#123; public static void main(String args[])&#123; int age = 18; int age = 16; if(age &gt;= 18)&#123; System.out.println("成年。"); &#125;else if(age &gt; 18 &amp;&amp; age &lt; 22)&#123; System.out.println("上大学"); &#125;else&#123; System.out.println("未成年。"); &#125; &#125;&#125; switch分支结构使用if else可以实现条件判断，但多数值判断需要用到switch完成，需要注意的是switch只支持：最初 - int、charjdk1.4开始 - 枚举jdk1.7开始 - String格式：123456789101112131415switch(数字、枚举、字符、字符串)&#123; case 内容1:&#123; 内容满足时执行的语句 break; &#125; case 内容2:&#123; 内容满足时执行的语句 break; &#125; ... default:&#123; 都不满足时执行的语句 break; &#125;&#125; 12345678910111213141516171819public class Demo&#123; public static void main(String args[])&#123; int ch = 1; switch(ch)&#123; case 1:&#123; System.out.println("内容为1"); //break; &#125; case 2:&#123; System.out.println("内容为2"); break; &#125; default:&#123; System.out.println("没有内容。"); //break; &#125; &#125;//输出“内容为1”、“内容为2” &#125;&#125; switch这种开关语句，如果case中没有加入break，语句会在满足case后一直执行直到遇见break或全部结束。12345678910111213141516171819public class Demo&#123; public static void main(String args[])&#123; String info = "Hello!"; switch (info)&#123; case "Hello!":&#123; System.out.println("你好！"); break; &#125; case "Sorry.":&#123; System.out.println("对不起..."); break; &#125; default:&#123; System.out.println("没有。"); break; &#125; &#125; &#125;&#125; 循环结构某几行代码被一直重复执行的操作形式。 while循环循环的初始化内容 while: 1234while(循环的结束条件判断)&#123; 循环语句; 修改循环结束条件判断;&#125; do while: 1234do&#123; 循环语句; 修改循环结束条件判断;&#125;while(循环的结束条件判断); 代码实例：123456789101112public class Demo&#123; public static void main(String args[])&#123; int num = 1; int num = 101; int result = 0; while(num &lt;= 100)&#123; //循环的结束条件判断 result += num; //result = result + num; num++; //循环条件变更 &#125; System.out.println(result);//5050 &#125;&#125; while如果判断条件不满足就一次都不执行，而do while即使判断条件不满足也会执行一次：123456789101112public class Demo&#123; public static void main(String args[])&#123; int num = 1; int num = 101; int result = 0; do&#123; result += num; num++; &#125;while(num &lt;= 100); System.out.println(result); //101，执行了result +=num与num++ &#125;&#125; for循环格式：123for(循环初始化条件; 循环结束判断; 修改循环条件)&#123; 循环体代码;&#125; 代码实例：123456789public class Demo&#123; public static void main(String args[])&#123; int result = 0; for(int x = 0; x &lt;= 100; x++)&#123; result += x; &#125; System.out.println(result); //5050 &#125;&#125; 循环控制循环处理有两类关键字：continue与break（一般结合if判断一起使用）。 continue执行到此语句，将跳过当前循环，返回到循环判断出进行处理。123456789public class Demo&#123; public static void main(String args[])&#123; int result = 0; for(int x = 0; x &lt;= 100; x++)&#123; result += x; &#125; System.out.println(result); //5050 &#125;&#125; 输出： x = 0 x = 1 x = 2 x = 4 x = 5 x = 6 x = 7 x = 8 x = 9 利用continue实现go to功能：1234567891011121314151617181920212223242526272829303132333435363738public class Demo&#123; public static void main(String args[])&#123; mp: for(int x = 0; x &lt; 5; x++)&#123; for(int y = 0; y &lt; 3; y++)&#123; if (x &gt; 2) &#123; continue mp; &#125; System.out.println("x = " + x + ", y = " + y); //输出： //x = 0, y = 0 // x = 0, y = 1 // x = 0, y = 2 // x = 1, y = 0 // x = 1, y = 1 // x = 1, y = 2 // x = 2, y = 0 // x = 2, y = 1 // x = 2, y = 2 // x = 3, y = 0 // x = 3, y = 1 // x = 3, y = 2 // x = 4, y = 0 // x = 4, y = 1 // x = 4, y = 2 //未屏蔽： // x = 0, y = 0 // x = 0, y = 1 // x = 0, y = 2 // x = 1, y = 0 // x = 1, y = 1 // x = 1, y = 2 // x = 2, y = 0 // x = 2, y = 1 // x = 2, y = 2 &#125; &#125; &#125;&#125; break12345678910public class Demo&#123; public static void main(String args[])&#123; for(int x = 0; x &lt; 10; x++)&#123; if(x == 3)&#123; break;//执行此语句后，之后的所有内容都不执行 &#125; System.out.println("x = " + x); &#125; &#125;&#125; 输出： x = 0 x = 1 x = 2 循环嵌套1234567891011121314151617181920212223public class Demo&#123; public static void main(String args[])&#123; //打印乘法口诀表 for(int x = 1; x &lt;= 9; x++)&#123; for(int y = 1; y &lt;= x; y++)&#123; System.out.print(x + "*" + y + "=" + x * y + "\t"); &#125; System.out.print("\n"); &#125; //打印三角形 int line = 10; for(int x = 0; x &lt; line; x++)&#123; for(int y = 0; y &lt; line - x; y++)&#123; System.out.print(" "); &#125; for(int y = 0; y &lt; x; y++)&#123; System.out.print("* "); &#125; System.out.print("\n"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（方法的基本定义、重载、递归）]]></title>
    <url>%2F2018%2F06%2F18%2FJava%E5%9F%BA%E7%A1%80%EF%BC%88%E6%96%B9%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89%E3%80%81%E9%87%8D%E8%BD%BD%E3%80%81%E9%80%92%E5%BD%92%EF%BC%89%2F</url>
    <content type="text"><![CDATA[方法的基本定义方法：可重复调用的代码块，主类中定义，主方法中调用。格式：1234public static 方法返回值 方法名称([参数类型，变量])&#123; 方法体代码; return 返回值;&#125; 返回值类型：void - 没有返回值数据类型 - 基本数据类型与引用数据类型 无参数与返回值的方法12345678910public class Demo&#123; public static void print()&#123; System.out.println("**************"); System.out.println("Hello World!"); System.out.println("**************"); &#125; public static vodi main(String args[])&#123; &#125;&#125; 有参数无返回值的方法12345678public class Demo&#123; public static void print(String msg)&#123; System.out.println(msg); &#125; public static void main(String args[])&#123; &#125;&#125; 有参数有返回值的方法12345678public class Demo&#123; public static int add(int x, int y)&#123; return x + y; &#125; public static void main(String args[])&#123; &#125;&#125; 如果某方法使用了void定义（无返回值），该方法可以直接用return来结束调用，一般这种return的处理需要结合if判断来实现。1234567891011public class Demo&#123; public static void print(int x)&#123; if(x == 20)&#123;//方法结束的判断 return;//此语句之后的代码不再执行 &#125; System.out.println("x=" + x);//"x = 10" &#125; public static void main(String args[])&#123; &#125;&#125; 方法重载方法名称相同，参数的类型或个数不同，根据参数的类型或个数的不同，执行不同的方法体。 123456789public class Demo&#123; public static void main(String args[])&#123; System.out.println("Hello!"); System.out.println(1); System.out.println(1.1); System.out.println('A'); System.out.println(true); &#125;&#125; System.out.println()是一个典型的、被重载的方法。 123456789101112131415161718192021public class Demo&#123; public static void main(String args[])&#123; System.out.println(add(10, 20)); System.out.println(add(10, 20, 30)); System.out.println(add(10.1, 20.2)); &#125; //被重载方法 public static int add(int x, int y)&#123; return x + y; &#125; //方法名称相同，参数个数不同 public static int add(int x, int y, int z)&#123; return x + y + z; &#125; //方法名称相同，参数类型不同 public static double add(double x, double y)&#123; return x + y; &#125;&#125; 开发原则：这样使用方法重载，很难确定返回值的类型，因此使用方法重载时，方法的返回值一定要相同。 方法递归方法自己调用自己的形式，一般需要递归时，满足以下特点： 方法必须有一个递归的结束条件； 每次递归处理的时候一定要做出一些变更。123456789101112131415161718192021222324252627282930313233343536//基本方法实现public class Demo&#123; public static void main(String args[])&#123; int num = 1; int result = 0; while(num &lt;= 100)&#123; result += num; num++; &#125; System.out.println(result); &#125;&#125;//递归实现public class Demo&#123; public static void main(String args[])&#123; System.out.println(sum(100)); &#125; public static int sum(int num)&#123; if(num == 1)&#123;//结束条件 return 1; &#125; return num + sum(num - 1); &#125;&#125;//递归实现阶乘public class Demo&#123; public static void main(String args[])&#123; System.out.println(mul(60)); &#125; public static double mul(int num)&#123; if(num == 1)&#123; return 1; &#125; return num * mul(num - 1);//8.320987112741392E81 &#125;&#125; 实现原理 “main()”调用：第一次执行sum()方法：return 100 + sum(100 - 1)； “sum()”递归：第二次执行sum()方法：return 99 + sum(99 - 1)； …… “sum()”递归：倒数第二次执行sum()方法：return 2 + sum(2 - 1)； “sum()”递归：最后一次执行sum()方法：return 1，从这里开始才嫩够满足之前的所有调用。]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（基本运算）]]></title>
    <url>%2F2018%2F06%2F18%2FJava%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基础数学运算加减乘除12345678910public class Demo&#123; public static void main(String args[])&#123; int x = 10; int y = 20; System.out.println(x + y); System.out.println(x - y); System.out.println(x * y); System.out.println(x / y); &#125;&#125; 运算符的优先级1234567public class Demo&#123; public static void main(String args[])&#123; int x = 10; int y = 20; System.out.println((x + y) * (x - y)); &#125;&#125; 自增与自减（++变量与变量++）++变量1234567public class Demo&#123; public static void main(String args[])&#123; int result = ++x * y; System.out.println(result); //220 先自增后相乘 11*20 System.out.println(x); //11 &#125;&#125; 变量++1234567public class Demo&#123; public static void main(String args[])&#123; int result = x++ * y; System.out.println(result); //200 先相乘后自增 10*20 System.out.println(x); //11 &#125;&#125; 自减同理。 三目运算符三目是一种赋值运算，是根据条件来进行判断，格式：数据类型 变量 = 布尔表达式 ? 条件满足时赋值的内容 ： 条件不满足时赋值内容12345678public class Demo&#123; public static void main(String args[])&#123; int x = 10; int y = 20; int result = x &gt; y ? x : y; System.out.println(result); //20 &#125;&#125; 关系运算符所有关系运算符判断完成的数据返回结果都是布尔类型12345678910public class Demo&#123; public static void main(String args[])&#123; int x = 10; int y = 20; System.out.println(x &gt; y); //flase System.out.println(x &lt; y); //true System.out.println(x == y); //false System.out.println(x == y ? x * 2 : y - 3 * 2); //14 &#125;&#125; 如果现在使用字符判断可以直接将字符与数字进行判断123456public class Demo&#123; public static void main(String args[])&#123; System.out.println('a' == 97); //true System.out.println('0' == 0); //false &#125;&#125; 逻辑运算符与与： &amp; 与 &amp;&amp; &amp;12345678public class Demo&#123; public static void main(String args[])&#123; System.out.println(10 / 0); //报错，10不能除以0 if(1 &gt; 2 &amp; 10 / 0 == 0)&#123; System.out.println("条件满足！");//报错，10 / 0仍被执行了 &#125; &#125;&#125; &amp;&amp;一般的，当使用“&amp;”时表示多个条件都需要满足判断，可如果我们前面已经有条件返回了false，后面即便有非常多个true，判断结果仍是false，因此可以使用短路与“&amp;&amp;“ 123456789public class Demo&#123; public static void main(String args[])&#123; if(1 &gt; 2 &amp;&amp; 10 / 10 == 0)&#123; System.out.println("条件满足！");//“条件满足！”，10 / 0未被执行 &#125;else&#123; System.out.println("条件不满足！"); &#125; &#125;&#125; 从性能的角度来说，短路与比单与要好。 或或： | 与 || |123456789public class Demo&#123; public static void main(String args[])&#123; if(1 &lt; 2 | 10 / 0 == 0)&#123; System.out.println("条件满足！");//报错，10 / 0仍被执行了 &#125;else&#123; System.out.println("条件不满足！"); &#125; &#125;&#125; ||123456789public class Demo&#123; public static void main(String args[])&#123; if(1 &lt; 2 || 10 / 0 == 0)&#123; System.out.println("条件满足！");//“条件满足！”，10 / 0未被执行 &#125;else&#123; System.out.println("条件不满足！"); &#125; &#125;&#125; 非123456public class Demo&#123; public static void main(String args[])&#123; System.out.println(10 &gt; 20); //true System.out.println(!(10 &gt; 20)); //false &#125;&#125; 按位或、按位与123456789public class Demo&#123; public static void main(String args[])&#123; int numA = 19; int numB = 5; int numC = 2; System.out.println(numA &amp; numB); //1 System.out.println(numA | numB); //23 &#125;&#125; 19 : 100115 : 0010119 &amp; 5 = 00001 = 119 | 5 = 10111 = 23 数据移位12345678public class Demo&#123; public static void main(String args[])&#123; int numA = 19; int numB = 5; int numC = 2; System.out.println(numC &lt;&lt; 2); //8 &#125;&#125; 2 : 000102 &lt;&lt; 2 : 01000 = 8123456789public class Demo&#123; public static void main(String args[])&#123; int num = 023; System.out.println(num); //19，因为023是八进制 int num = 0x23; System.out.println(num); //35，因为0x23是十六进制 &#125;&#125; &amp;&amp;与&amp;、||与|的区别 逻辑运算： &amp;&amp; - 逻辑与，前面只要出现一个判断条件返回false，后面的条件不再判断，最终结果为false； &amp; - 所有判断条件都要执行； || - 逻辑或，前面只要出现一个判断条件返回true，后面的条件不再判断。最终结果为true； | - 所有判断条件都要执行； 位运算： &amp; - 运算的两个数据位如果有一个为0，结果就是0，全为1时结果才为1； | - 运算的两个数据为只要有一个为1，结果就是1；]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（数据类型）]]></title>
    <url>%2F2018%2F06%2F18%2FJava%E5%9F%BA%E7%A1%80%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据类型简介基本数类型 数据类型 包含类型 默认值 整形 byte、short、int、long 0 浮点型 float、double 0.0 字符型 char ‘\u0000’ 布尔型 boolean false 引用数据类型 数据类型 默认值 数组 null 类 null 接口 null 整型整型变量概况12345678910111213public class Demo&#123; public static void main(String args[])&#123; int maxValue = Integer.MAX_VALUE; //取最大值 int minValue = Integer.MIN_VALUE; //取最小值 System.out.println(maxValue); //整型int的最大值是2147483647 System.out.println(minValue); //整型int的最小值是-2147483648 System.out.println(maxValue + 1); //-2147483648 System.out.println(minValue - 1); //2147483647 System.out.println(minValue - 2); //2147483646 long result = maxValue + 1; System.out.println(result); //结果仍是-2147483648，因为程序的执行都是从右到左，result变量仍然是int型 &#125;&#125; 短整型的扩充方法（一）：直接将int变量赋值给long变量123456public class Demo&#123; public static void main(String args[])&#123; long result = maxValue; System.out.println(result + 1); //2147483648, long + int = long &#125;&#125; 短整型的扩充方法（二）：直接将int变量变为long变量123456public class Demo&#123; public static void main(String args[])&#123; long result = (long)maxValue + 1; System.out.println(result); &#125;&#125; 数据类型由大变小：直接将int变量变为long变量以上属于将数据从小变大，也可以实现由大变小，但需要强制完成，因此有可能导致内容的丢失。12345public class Demo&#123; public static void main(String args[])&#123; long num = 2147483648; //报错：过大的整数，因为所有整数的默认类型都是int，而2147483648已经超过int的数据范围 &#125;&#125; 解决方案:数据末尾加L1234567public class Demo&#123; public static void main(String args[])&#123; long num = 2147483648L; //若不加L，2147483648默认为int型 int result = (int)num; //由大变小 System.out.println(result); //-2147483648 &#125;&#125; 范围小的数据类型可自动变为范围大的数据类型，范围大的数据类型需要强制转换才能变为范围小的数据类型。 默认类型无效的情况数据的默认类型在方法的声明（如main）中无效123456public class Demo&#123; public static void main(String args[])&#123; int num; System.out.println(num); //报错，可能尚未初始化变量 &#125;&#125; 解决方案： 使用前赋值：num = 1，老版本的JDK中仍会出错； 声明变量时赋值：int num = 1，最保险的方法； 数据类型的默认值需要结合到类的角度来考虑。 不需要强制转换的情况某些情况下数据由大转换到小不需要强制转换123456public class Demo&#123; public static void main(String args[])&#123; byte data = 10; System.out.println(data); //输出10 &#125;&#125; 按照前面的思路，10为整数，默认int型，int的范围大于byte，理论上需要强制转换，但此时不用转换，因为其数据量符合byte的要求。如果数据量大于byte的范围，就需要强制转换了，如：12345678public class Demo&#123; public static void main(String args[])&#123; byte data = 128; System.out.println(data); //报错，不兼容的类型 byte data = (byte)128; System.out.println(data); //输出-128，溢出 &#125;&#125; 只能将int型常量赋值给byte型变量，而不能将int型变量赋值给byte型变量，如：123456public class Demo&#123; public static void main(String args[])&#123; int num = 10; byte data = num; //报错，不兼容的类型 &#125;&#125; 解决方案：强制转换123456public class Demo&#123; public static void main(String args[])&#123; int num = 10; byte data = (byte)num; &#125;&#125; 浮点型表示小数默认使用double。123456public class Demo&#123; public static void main(String args[])&#123; double num = 10.2; System.out.println(num * 2); //20.4, double * int = double &#125;&#125; 输出20.4，double * int = double。 float型变量的定义float也可以表示小数，但float范围小于double，如何定义float变量？因为小数默认类型为double，结合前面long num = 2147483648的问题，在数字末尾加上F即可。如：123456789public class Demo&#123; public static void main(String args[])&#123; float num = 1.1; //报错，不兼容的类型 System.out.println(num); float num = 1.1F; System.out.println(num * 2); //2.2, float * int = float System.out.println(1.1 * 1.1); //1.2100000000000002 JDK的bug &#125;&#125; 整型的计算精度问题1234567public class Demo&#123; public static void main(String args[])&#123; int num1 = 10; int num2 = 4; System.out.println(num1 / num2); //输出2 &#125;&#125; 输出2，是整型，没有小数点，因为int / int = int。如果要进行准确计算，必须要有一个变量是double或float型，如：12345678public class Demo&#123; public static void main(String args[])&#123; int num1 = 10; int num2 = 4; System.out.println(num1 / (double)num2); //2.5 System.out.println((float)num1 / num2); //2.5 &#125;&#125; 字符型字符型用char来声明，并用’’声明，字符型可以与int相互转换。123456public class Demo&#123; public static void main(String args[])&#123; char c = 'A'; System.out.println(c); //A &#125;&#125; 字符与编码所有字符在程序之中都是通过编码来描述，因此char变量变为int内容的时候，其包含的就是编码。1234567public class Demo&#123; public static void main(String args[])&#123; char c = 'A'; int num = c; //将字符变为int型 System.out.println(num); //65 &#125;&#125; 常用范围 大写字母A~Z:65(A)到90(Z) 小写字母a~z:97(a)到122(z) 差了32个长度。 大小写字母转换123456789public class Demo&#123; public static void main(String args[])&#123; char c = 'A'; int num = c + 32; System.out.println(num); //97, char + int = int char x = (char)num; //强制转换 System.out.println(x); //a &#125;&#125; 字符’0’与数字0注意，字符0与数字0不是一个概念！12345678public class Demo&#123; public static void main(String args[])&#123; char c = '0'; int num = c; System.out.println(num); //48 System.out.println('0' == 0); //false &#125;&#125; 字符’0’~’9’的编码是48(0)到57(9)。 中文字符Java中使用Unicode编码，包含ASCII码，但包含内容包含ASII码，Unicode 16进制，可以保存中文字符。123456789public class Demo&#123; public static void main(String args[])&#123; char c = '汪'; int num1 = c; System.out.println(num1); //27754 int num2 = c + 2; System.out.println((char)num2); //汬 &#125;&#125; 神奇的中文字符命名程序：12345678public class 程序类&#123; public static void main(String args[])&#123; int 变量1 = 10; int 变量2 = 20; int 结果 = 变量1 * 变量2; System.out.println(结果); &#125;&#125;; 布尔型123456789public class Demo&#123; public static void main(String args[])&#123; boolean flag = 10 &gt; 2; boolean b = 1; //报错，不兼容类型，Java中布尔型变量只能赋true或false if(flag)&#123; System.out.println("Hello World!"); &#125; &#125;&#125; 字符串型char只能描述单一字符，多个字符只能用字符串(String)来表示，但String不是基本数据类型，而是引用数据类型，在使用中比较特殊，可以按照基本数据类型的使用方法来使用。1234567public class Demo&#123; public static void main(String args[])&#123; String name = "Weo"; String adj = "\thandsome"; System.out.println(name + adj); //Weo handsome &#125;&#125; String变量也可以用“+”连接，一旦使用“+”，则描述的是两个字符串的连接。但“+”在数学运算中是数字的相加操作，在String中是连接操作，如果同时出现呢？12345678910public class Demo&#123; public static void main(String args[])&#123; int numA = 10; double numB = 20.2; String result1 = "Math" + numA + numB; System.out.println(result1); //Math1020.2 String result2 = "Math" + numA - numB; System.out.println(result2); //报错，字符串不能减数字 &#125;&#125; 只要在“+”的操作中出现字符串，则“+”仅做连接作用，所有的类型都变为String类型后再进行连接，包含基本类型与引用类型，如果一定要在有String参与的“+”操作中进行数学计算，则应当使用”()”，如：12345678public class Demo&#123; public static void main(String args[])&#123; int numA = 10; double numB = 20.2; String result3 = "Math" + (numA + numB); System.out.println(result3); //Math30.2 &#125;&#125; 常用转义字符 \n 换行 \t 制表 \” 双引号 \’ 单引号 \\ 单斜杠 12345public class Demo&#123; public static void main(String args[])&#123; System.out.println("欣旺达\t\"呵呵\"\n傻逼公司"); &#125;&#125;]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛神赋]]></title>
    <url>%2F2017%2F09%2F17%2F%E6%B4%9B%E7%A5%9E%E8%B5%8B%2F</url>
    <content type="text"><![CDATA[魏晋：曹植 黄初三年，余朝京师，还济洛川。古人有言，斯水之神，名曰宓妃。感宋玉对楚王神女之事，遂作斯赋，其词曰： 余从京域，言归东藩，背伊阙，越轘辕，经通谷，陵景山。日既西倾，车殆马烦。尔乃税驾乎蘅皋，秣驷乎芝田，容与乎阳林，流眄乎洛川。于是精移神骇，忽焉思散。俯则未察，仰以殊观。睹一丽人，于岩之畔。乃援御者而告之曰：“尔有觌于彼者乎？彼何人斯，若此之艳也！” 御者对曰：“臣闻河洛之神，名曰宓妃。然则君王所见，无乃是乎？其状若何，臣愿闻之。” 余告之曰：其形也，翩若惊鸿，婉若游龙，荣曜秋菊，华茂春松。髣髴兮若轻云之蔽月，飘飖兮若流风之回雪。远而望之，皎若太阳升朝霞。迫而察之，灼若芙蕖出渌波。秾纤得衷，修短合度。肩若削成，腰如约素。延颈秀项，皓质呈露，芳泽无加，铅华弗御。云髻峨峨，修眉联娟，丹唇外朗，皓齿内鲜。明眸善睐，靥辅承权，瓌姿艳逸，仪静体闲。柔情绰态，媚于语言。奇服旷世，骨像应图。披罗衣之璀粲兮，珥瑶碧之华琚。戴金翠之首饰，缀明珠以耀躯。践远游之文履，曳雾绡之轻裾。微幽兰之芳蔼兮，步踟蹰于山隅。于是忽焉纵体，以遨以嬉。左倚采旄，右荫桂旗。攘皓腕于神浒兮，采湍濑之玄芝。 余情悦其淑美兮，心振荡而不怡。无良媒以接欢兮，托微波而通辞。愿诚素之先达兮，解玉佩以要之。嗟佳人之信修兮，羌习礼而明诗。抗琼珶以和予兮，指潜渊而为期。执眷眷之款实兮，惧斯灵之我欺。感交甫之弃言兮，怅犹豫而狐疑。收和颜而静志兮，申礼防以自持。 于是洛灵感焉，徙倚彷徨。神光离合，乍阴乍阳。竦轻躯以鹤立，若将飞而未翔。践椒涂之郁烈，步蘅薄而流芳。超长吟以永慕兮，声哀厉而弥长。 尔乃众灵杂遝，命俦啸侣。或戏清流，或翔神渚。或采明珠，或拾翠羽。从南湘之二妃，携汉滨之游女。叹匏瓜之无匹兮，咏牵牛之独处。扬轻袿之猗靡兮，翳修袖以延伫。体迅飞凫，飘忽若神。凌波微步，罗袜生尘。动无常则，若危若安。进止难期，若往若还。转眄流精，光润玉颜。含辞未吐，气若幽兰。华容婀娜，令我忘餐。 于是屏翳收风，川后静波。冯夷鸣鼓，女娲清歌。腾文鱼以警乘，鸣玉鸾以偕逝。六龙俨其齐首，载云车之容裔。鲸鲵踊而夹毂，水禽翔而为卫。于是越北沚，过南冈，纡素领，回清阳，动朱唇以徐言，陈交接之大纲。恨人神之道殊兮，怨盛年之莫当。抗罗袂以掩涕兮，泪流襟之浪浪。悼良会之永绝兮，哀一逝而异乡。无微情以效爱兮，献江南之明珰。虽潜处于太阴，长寄心于君王。忽不悟其所舍，怅神宵而蔽光。 于是背下陵高，足往神留。遗情想像，顾望怀愁。冀灵体之复形，御轻舟而上溯。浮长川而忘返，思绵绵而增慕。夜耿耿而不寐，沾繁霜而至曙。命仆夫而就驾，吾将归乎东路。揽騑辔以抗策，怅盘桓而不能去。 This is how I knew you.]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java4Android学习笔记（未完待续）]]></title>
    <url>%2F2017%2F06%2F23%2FJava4Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[其实写了以后可能也不会看，但还是动手敲一遍加深印象吧…… Java的基本概念环境变量通常指在操作系统中用来制定操作系统运行时所需要的一些参数，通常为一系列键值对。 Path环境变量操作系统外部命令搜索路径。如用命令行执行ipconfig命令时，实际上是运行系统文件夹中的”ipconfig.exe”，找到系统文件夹中的”ipconfig.exe”文件并将其改名为”iconfig.exe”时，再次在命令行中运行ipconfig命令时将会报错，操作系统是如何找到”ipconfig.exe”这个文件的呢？本机通过环境变量设置界面找到Path这个环境变量的值为（为便于阅读进行了换行）123456789101112C:\ProgramData\Oracle\Java\javapath;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Program Files (x86)\Intel\iCLS Client\;C:\Program Files\Intel\iCLS Client\;%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;...//（略）%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;D:\Android\android-sdk_r24.4.1-windows\android-sdk-windows\platform-tools;D:\git\Git\cmd;D:\node\ 可以看出基本上都是文件路径，当我们在命令行里执行一个命令时，会先在Path环境变量中的目录里逐条查找，本机中的目录为以上代码块中的第五行。当逐条查找目录仍未找到”ipconfig.exe”文件时，命令行将会报错，如“某命令不是内部或外部命令，也不是可运行的程序或批处理文件”。总结来说，要成功运行ipconfig命令，”ipconfig.exe”所在的文件夹的路径必须出现在Path这个环境变量中。因此代码块中倒数第五行即为执行Java命令所需要的路径，在Java安装路径（本机为C:\Program Files\Java\jdk1.8.0_112）中的bin文件夹下，有着一系列Java命令所对应的，后缀为”.exe”的文件（如”java.exe”、”javac.exe”）。 CLASSPATH环境变量类文件搜索路径，它的值如下所示123.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar 当我们执行java Hello命令来运行”Hello.class”这个文件时，”Hello.class”文件需要到哪里来寻找呢？在CLASSPATH这个环境变量中可以找到答案，代码块第一行中的”.;”表示的便是当前运行命令的文件路径，”Hello.class”便处于当前运行命令的文件夹中，寻找以”.class”结尾的类文件。 JDK中有些什么 “bin”文件夹：大多数为可执行文件（用得最多的两个可执行文件为”java.exe”和”javac.exe”）。 “demo”与”sample”文件夹：一些Java的范例，但对于初学者指导意义不大。 “include”文件夹：一些C语言程序。 “jre”文件夹：见下文。 “lib”文件夹：Java所需要的一些包文件。 “src.zip”：JDK的一部分源文件。 JRE是什么指Java运行环境，全程Java Runtime Environment，主要包括以下几个部分： Java虚拟机，即JVM(Java Virtual Machine)，是一个由软件虚拟出来的计算机。虚拟机首先将程序编译后的文件（”.class”文件）解释成适合当前操作系统的机器码，操作系统再将机器码交由硬件执行。同样的”.class”文件可交由不同虚拟机去解释成适合不同操作系统运行的机器码。Java虚拟机的存在使得相同的Java程序不需要做任何改动就能在不同的操作系统上运行。 Java平台核心类文件 其他支持文件 Java的变量什么是变量 计算机是一种极度精确的机器； 要将信息存储在计算机中，必须指明信息存储位置与所需内存空间； 在Java中，通过使用声明语句完成上述任务。 变量的声明int age = 20;“int”确定了数据类型，”age”确定了变量名，”=”为赋值号，”20”为变量值，”;”表示语句结束。这条语句使计算机分配足够空间用于存储一个整数，整数的名字为”age”，”int”是Java定义的一种数据类型，专门用于存储一定大小的整数。整个语句的意思是将赋值号右侧的值赋给赋值号左边的变量。 变量的类型123456789101112 |-整数类型(`byte`,`short`,`int`,`long`) |-数值型-| | |-浮点类型(`float`,`double`) |-基本数据类型-|---字符型(char) | | | |-布尔型(boolean)数据类型-| | |-类(class) | | |-引用数据类型-|---接口(interface) | |-数组 变量的命名规范变量命名语法规范 应以字母、下划线或美元符开头（如声明变量int 1age = 20;中的1age是不合法的）； 后跟字母、下划线、美元符或数字； Java的变量名没有长度限制（最好不要太长）； Java的变量名对大小写敏感（如int age = 20;与int Age = 20;两个声明语句中的age与Age是两个不同的变量）。 驼峰命名法 变量名应使用有意义的英文单词（忌用拼音）； 变量名若只有一个单词，则所有字母小写； 变量名若由多个英文单词构成，则从第二个单词开始首字母大写。 Java的基本数据类型布尔型变量(boolean) boolean类型适用于逻辑运算，一般用于程序流程控制； 在Java中boolean类型只有两种取值：true与false，如boolean b = false;（注意，Java中不能用0和非0、空和非空来表示！需要与JavaScript这种动态类型的语言区分开）； 字符型变量(char)用来表示通常意义上的字符。 字符是由单引号括起来的单个字符，如char c = &#39;a&#39;； Java字符使用Unicode字符集；先介绍ASCII字符集： 在计算机中，所有的数据都需要使用二进制来表示； 类似a,b,c一类的字母无法直接用二进制表示； 所以将常用符号进行了编号，标准ASCII码使用7位二进制数来表示字符； 7位二进制数可以表示所有的数字、大小写字母以及一些常见符号（如！、@、#、$等等）。Unicode字符集则为每种语言的每个字符设定了统一且唯一的二进制码： Unicode满足了跨语言文本转换和处理的需求； Unicode在互联网中扮演着相当重要的角色； Unicode使用数字0-0x10FFFF来表示字符； Unicode字符集最多允许有1114112个字符。 注意，在Unicode字符集中，一个英文字母与一个汉字所占用的存储空间都是一样的，不存在一个中文字符占用的两个字符，一个英文字符占用一个字符。Java在设计初期就考虑到该语言将广泛应用于互联网中，因此设计者们选用了Unicode字符集，方便Java在互联网中运用，所以类似char c = &#39;中&#39;;这样的语句是合法的。实际编程中遇到了问题，使用javac命令在命令行中编译.java文件时，命令行报错：“错误: 编码GBK的不可映射字符”。解决方案：用记事本打开文件后选择另存为，在“编码”选项中选择”ANSI”，这样就能顺利编译。测试程序：123456public class charTest&#123; public static void main(String args[])&#123; char c = '汉'; System.out.println(c); &#125;&#125; 数值型变量主要分为两大类。 整数类型 byte-比特型 short-短整型 int-整型 long-长整型 类型 占用存储空间 表示数的范围 byte 1字节 -128~127 short 2字节 -2^15~2^15-1 int 4字节 -2^31~2^31-1 long 8字节 -2^63~2^63-1 整数类型通常有三种表示形式： 十进制整数，如12，-314，0； 八进制整数，要求以0开头，如012； 十六进制，要求0x或0X开头，如0x12。Java语言的整型常量默认为int型，如int i = 3;。声明长整型常量(long) 可以后加’l’或’L’，如long l = 3L;（最好大写，防止被看作数字1）。 浮点类型 float-单精度浮点型 double-双精度浮点型 类型 占用存储空间 表示数的范围 float 4字节 -3.403E38~3.403E38 double 8字节 -1.798E308~1.798E308 练习题（一）创建一个Java源文件，命名为”Exerc01.java”，在主函数中创建一个boolean类型的变量，并为这个变量赋值（true，false和0），然后将这个变量打印出来。12345678public class Exerc01&#123; public static void main(String args[])&#123; //boolean b = true; //boolean b = false; boolean b = 0; System.out.println(b); &#125;&#125; 创建一个Java源文件，命名为”Exerc02.java”，在主函数中创建一个char类型的变量，并为这个变量赋值（中文或英文字符）， 然后将这个变量打印出来。1234567public class Exerc02&#123; public static void main(String args[])&#123; //char c = 'a'; char c = '汉'; System.out.println(c); &#125;&#125; 创建一个Java源文件，命名为”Exerc03.java”，在主函数中创建所有数值型变量，并赋值， 然后进行加减乘除运算。12345678910111213141516public class Exerc03&#123; public static void main(String args[])&#123; byte b = 0; short s = 0; int i = 0; long l = 1; float f = 0.1F; double d = 0; //i = l; //System.out.println(b); //int j = 0.5*10; double j = 0.5*10; byte k = (byte)(b + 200); System.out.println(k);//输出为一个很奇怪的值：-56 &#125;&#125; 字面量：表示代码中一个变量字面上的值，其整数均为整型，其小数部分均为双精度浮点型。在代码float f = 0.1;中，将一个双精度浮点型字面量(double)赋给了一个单精度浮点型变量(float)，双精度浮点型变量的表数范围比单精度浮点型变量的表数范围要大，因此程序可能报错（如，从大桶向小桶中倒水，若大桶中水的体积大于小桶的容积，水会溢出）。可用float f = 0.1F;强制转换。整型(int)、长整型(long)与短整型(short)之间的关系同理。代码byte b = 0;与short s = 0;将整型的字面量赋给了比特型变量与短整型变量，按常理来说应该会像上述情况一样报错，但实际不会，因为在Java中，可以使用整型的字面量给比特型变量与短整型变量赋值。代码int j = 0.5 * 10;编译报错，是因为0.5这个字面量，整数部分是整型，小数部分是双精度浮点型，双精度浮点型的字面量与任何其他数值型的字面量进行四则运算，其结果都为双精度浮点型，总结来说就是四则运算结果的类型以参与运算的字面量中表数范围最大的字面量为准，因此代码double j = 0.5 * 10;不会报错，而代码byte k = b + 0;则会报错，原因是运算结果的类型应为参与运算字面量中表数范围最大的字面量的类型，即整型，int k = b + 0;则不会报错。另外强制转换也可以避免类型问题，但可能使代码存在不可预知的错误。数值型变量的表数范围关系：byte &lt; short &lt; int &lt; long &lt; double Java的运算符与表达式Java中的常见运算符及其使用方法算数运算符+, -, *, /, %, ++, -- 有代码int i = 3 / 2;，将变量i打印出来，发现结果是1，原因是四则运算结果的类型以参与的运算字面量中表数范围最大的字面量为准，即整型，因此小数位全部被忽略。 1234567public class Test&#123; public static void main(String args[])&#123; //int i = 3 / 2; double i = 3 / 2.0; System.out.println(i); &#125;&#125; i++与++i的区别：i++是先让i参与运算，再使i增加1；++i是先让i增加1，再让i参与运算。 123456789101112131415161718public class Hello&#123; public static void main(String args[])&#123; //int i = 5; //int j = i++ +5; /** int k = i + 5; i = i + 1; **/ int i = 5; int j = ++i +5; /** i = i + 1; int k = i + 5; **/ System.out.println(j); System.out.println(i); &#125;&#125; 关系运算符&gt;, &lt;, &gt;=, &lt;=, ==, !=12345678910public class Test&#123; public static void main(String args[])&#123; int i = 5; //int j = 6; int j = 5; //boolean b = i &gt; j; boolean b = i == j; System.out.println(b); &#125;&#125; 布尔逻辑运算符!, &amp;, |, ^, &amp;&amp;, ||真值表 a b !a a&amp;b a&#124;b a^b a&amp;&amp;b a&#124;&#124;b true true false true true false true true true false false false true true false true false true true false true true false true false false true false false false false false ! - 逻辑非， 将布尔变量a取反； &amp; - 逻辑与。a&amp;b中的两个布尔变量只要一个为假，则运算结果为假。 | - 逻辑或。a|b中的两个布尔变量只要一个为真，则运算结果为真。 ^ - 逻辑异或。 &amp;&amp; - 短路与。a&amp;&amp;b中的a若为真，则继续判断b为真还是假，若b为真，则结果为真，若b为假，则结果为假；a若为假，则不再判断b是否真假，结果为假。 || - 短路或，a||b中的a若为假，则继续判断b为真还是假，若b为真，则结果为真，若b为假，则结果为假；a若为真，则不再判断b是否真假，结果为真。 &amp;与&amp;&amp;（|与||）的区别：&amp;与&amp;&amp;123456789101112131415public class Test&#123; public static void main(String args[])&#123; //boolean a = true; //boolean b = false; //boolean c = a &amp; b; //boolean d = a &amp;&amp; b;//常规判断时与和短路与用法基本相同 //System.out.println(c); //System.out.println(d); int i = 5; //boolean e = i &gt; 6 &amp; i++ &gt; 7;//false与上false，结果即为flase //System.out.println(i);结果为6，i增加了1 boolean e = i &gt; 6 &amp;&amp; i++ &gt; 7;//false短路与上false，结果即为flase System.out.println(e);//结果为5，i没有变化，因为短路与先判断前一个条件`i &gt; 6`是否为假，如果为假，则后一个条件不用再去判断，因此`i++`并未被执行，i未增加1 &#125;&#125; |与||的区别可以此类推。 位运算符&amp;, |, ^, ~, &gt;&gt;, &lt;&lt;, &gt;&gt;&gt; 赋值运算符=, +=, -=, *=, /=（后四个为拓展赋值运算符）+=:123456public class Test&#123; public static void main(String args[])&#123; int i = 5; i += 5;//即为i = i + 5 &#125;&#125; 其他拓展赋值运算符以此类推。 字符串连接运算符+ 表达式的类型和值表达式，是符合一定语法规则的运算符与操作符的序列，如i、10.5 + i、(i + j) - 2。 表达式的值对表达式的中操作数进行运算得到的结果，称之为表达式的值。 表达式的类型表达式的值的数据类型，即为表达式的类型。 分支语句程序运行流程的分类顺序结构代码一行一行向下执行。1语句1-&gt;语句2-&gt;语句3 分支结构设定条件，符合条件时程序才继续执行，否则不执行。12345语句1 | 假判断语句----- |真 |语句3 语句4 循环结构程序从头运行到位后再从头开始。 if…else…分支结构（一）语法结构：if(布尔类型表达式){ 语句1; 语句2;}语句3;语句4； 示例代码：12345678public class Test&#123; public static void main(String args[])&#123; int i = 12; if(i &lt;= 10)&#123; System.out.println("i小于等于10。"); &#125; &#125;&#125; （二）语法结构：if(布尔类型表达式){ 语句1; 语句2;}else{ 语句3; 语句4;} 示例代码：1234567891011public class Test&#123; public static void main(String args[])&#123; int i = 12; if(i &lt;= 10)&#123; System.out.println("i小于等于10。"); &#125; else&#123; System.out.println("i大于10。"); &#125; &#125;&#125; （三）语法结构：if(布尔类型表达式){ 语句1; 语句2;}else if{ 语句3; 语句4;}else if{ 语句5; 语句6;}else{ 语句7; 语句8;}注意，最后的else{}是可有可无的。 示例代码：1234567891011public class Test&#123; public static void main(String args[])&#123; int i = 1; if(i &lt; 0)&#123; System.out.println("i为负数。"); &#125; else if(i &gt; 0)&#123; System.out.println("i为正数。"); &#125; &#125;&#125; 注意，以下代码123456789101112131415public class Test&#123; public static void main(String args[])&#123; int i = -1; if(i &lt; 0)&#123; System.out.println("i为负数。"); &#125; else if(i++ &gt; 0)&#123; System.out.println("i+1的值大于0"); &#125; else&#123; System.out.println("i既不为负数也不大于-1。"); &#125; System.out.println(i); &#125;&#125; 其输出结果为12i为负数-1 这说明无论else if{}语句有多少个，只要第一个else if{}语句为真，之后的else if{}语句便不再执行；若第一个else if{}语句为假，则执行后一个else if{}语句，直到该else if{}语句为真。我们把以上代码做少许修改123456789101112131415public class Test&#123; public static void main(String args[])&#123; int i = -1; if(i++ &gt; 0)&#123; System.out.println("i+1的值大于0"); &#125; else if(i &lt; 0)&#123; System.out.println("i为负数。"); &#125; else&#123; System.out.println("i既不为负数也不大于-1。"); &#125; System.out.println(i); &#125;&#125; 其输出结果为12i既不为负数也不大于-1。0 变量i的值变成了0而不是-1，说明i++这个语句被执行了。 switch分支结构语法结构：switch(表达式){ //注意此处表达式并不是布尔型表达式 case 常量1: 语句1; break; case 常量2: 语句2; break; … default: 默认语句; break;}default:部分同样可以省略。值得注意的是，switch()和case ***:中的表达式类型不能为布尔类型，只能为这四种类型：byte, short, int, char。PS:新版JDK中还支持字符串类型（String）。12345678910111213141516171819public class Test&#123; public static void main(String args[])&#123; char c = 'a'; switch(c)&#123; case 'a': System.out.println('a'); break; case 'b': System.out.println('b'); break; case 'c': System.out.println('c'); break; default: System.out.println('d'); break; &#125; &#125;&#125; break;的作用是让代码不再向下执行，default:中的break;在最后，可以省略。 练习题（二）将学生分数按照标准分为优、良、中、差四个级别。步骤：1.创建一个名为Test01的类；2.在Test01类当中加入主函数；3.在主函数中定义一个整型变量用于表示学生分数；4.使用if…else…结构对分数进行分级。12345678910111213141516171819202122public class Test01&#123; public static void main(String args[])&#123; //int score = 90; //int score = 61; int score = -1; if(score &gt; 85 &amp;&amp; score &lt;= 100)&#123; System.out.println("High Distinction"); &#125; else if(score &gt; 75 &amp;&amp; score &lt;= 85)&#123; System.out.println("Distinction"); &#125; else if(score &gt; 60 &amp;&amp; score &lt;= 75)&#123; System.out.println("Credit Pass"); &#125; else if(score &gt;= 0 &amp;&amp; score &lt;= 60)&#123; System.out.println("Pass"); &#125; else&#123; System.out.println("Error"); &#125; &#125;&#125; 猜拳游戏。步骤：1.创建一个名为Test02的类；2.在Test02类当中加入主函数；3.在主函数中定义两个char类型变量，分别代表两个玩家的出拳；4.使用if…else…结构对结果进行判断。12345678910111213141516171819202122232425262728293031323334353637public class Test02&#123; public static void main(String args[])&#123; //s - 石头(shitou)，j - 剪刀(jiandao)，b - 布(bu) int player1 = 's'; int player2 = 'j'; if(player1 == 's' &amp;&amp; player2 == 's' )&#123; System.out.println("Equalize."); &#125; else if(player1 == 'j' &amp;&amp; player2 == 'j')&#123; System.out.println("Equalize."); &#125; else if(player1 == 'b' &amp;&amp; player2 == 'b')&#123; System.out.println("Equalize."); &#125; else if(player1 == 's' &amp;&amp; player2 == 'j')&#123; System.out.println("Player1 wins."); &#125; else if(player1 == 's' &amp;&amp; player2 == 'b')&#123; System.out.println("Player2 wins."); &#125; else if(player1 == 'j' &amp;&amp; player2 == 's')&#123; System.out.println("Player2 wins."); &#125; else if(player1 == 'j' &amp;&amp; player2 == 'b')&#123; System.out.println("Player1 wins"); &#125; else if(player1 == 'b' &amp;&amp; player2 == 's')&#123; System.out.println("Player1 wins"); &#125; else if(player1 == 'b' &amp;&amp; player2 == 'j')&#123; System.out.println("Player2 wins"); &#125; else&#123; System.out.println("Error!"); &#125; &#125;&#125; 循环语句循环结构在不少实际问题中有许多具有规律性的重复操作，因此在程序中就需要重复执行某些语句。一组被重复执行的语句称之为循环体，能否继续重复，决定循环的终止条件。循环结构是在一定条件下反复执行某段程序的流程结构，被反复执行的程序被称为循环体。循环语句是由循环体及循环的终止条件两部分组成的。 for循环语句举例：123456789public class TestFor&#123; public static void main(String args[])&#123; System.out.println("Ready to get into loop."); for(int i = 0; i &lt; 10; i++)&#123; System.out.println(i); &#125; System.out.println("Loop ends."); &#125;&#125; 输出结果：123456789101112Ready to get into loop.0123456789Loop ends. while循环语句举例：12345678public class TestWhile&#123; public static void main(String args[])&#123; while(i &lt; 10)&#123; System.out.println(i); i++; &#125; &#125;&#125; 输出结果：123456789100123456789 练习题（三）打印出100-200之间所有的素数。1234567891011121314public class TestPrimeNumber&#123; public static void main(String args[])&#123; for(int i = 100; i &lt;= 200; i++)&#123; boolean f = false; for(int j = 2; j &lt; i; j++)&#123; if(i % j == 0)&#123; f = true; &#125; &#125; if(f == false)&#123; System.out.println(i); &#125; &#125; &#125; 输出结果：123456789101112131415161718192021101103107109113127131137139149151157163167173179181191193197199 在命令行中打印出一个由“*”组成的四层金字塔。12345678910111213public class Prymaid&#123; public static void main(String args[])&#123; for(int i = 0; i &lt; 4; i++)&#123; for(int k = 0; k &lt; 4-i; k++)&#123; System.out.print(" "); &#125; for(int j = 0; j &lt;= i; j++)&#123; System.out.print("* "); &#125; System.out.println(""); &#125; &#125;&#125; 输出结果：1234 * * * * * ** * * * 思考，如何打印出任意行数的金字塔？待续。]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在二十二岁生日的最后一刻]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%86%99%E5%9C%A8%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%B2%81%E7%94%9F%E6%97%A5%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%88%BB%2F</url>
    <content type="text"><![CDATA[不知不觉，到法定结婚年龄了，虽然感情生活依旧一片空白，哈哈。其实一直不太愿意让别人知道自己的生日，具体原因我自己也说不上来……父母早在农历生日时向我表达了祝福，令我感到意外的是第一个给我发来慰问的人居然是某直播平台认识的一个主播。我并不是那种流着口水看女主播在屏幕上搔首弄姿的人，第一次点进这个主播的直播间时里面才十几个人。她是大连人，在浙江某中外合作办学院校上学，喜欢音乐和短道速滑，特别爱笑，有时候听她说话心情都会莫名其妙好起来。工作早些时候已经敲定了下来，也算幸运，现在就等顺利毕业准备入职了。最近颈椎感觉有点不舒服，得加强锻炼了。最后谢谢各位还记得我生日的朋友，无论是社交软件提醒（我明明在临近几天把生日改了…）还是一直记得的。也感谢不记得的朋友们，我不是那种sociable的人，能有你们已足够幸运。 PS:刚刚准备更新博客时看到某个移民群群友PTE考出八炸的好消息，备受鼓舞，感觉以后可以试试用英文写博客，犯一大堆错误也不要紧，至少能有环境输出。]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>生日</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于冶金的一些记忆]]></title>
    <url>%2F2017%2F04%2F27%2F%E5%85%B3%E4%BA%8E%E5%86%B6%E9%87%91%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BF%86%2F</url>
    <content type="text"><![CDATA[前几天在微博上看几个高中学姐撕逼，其中一个当事人抛出了一句“珠晖区冶金厂的girl”，看到“冶金”这两个字的时候，内心像是被什么戳中了似的，开始思索关于冶金的一些记忆。 冶金，是对原衡阳有色冶金机械总厂及其家属区周围的统称。 出入口：在我看来有七个。 茅坪街三中旁的路口； 东风立交桥旁的路口； 三化小路； 望江里通往河边的地洞口； 冶金厂门口旁八角塘原啤酒厂的小地洞口； 新风里单身宿舍与垃圾站中间一个可以越过铁路的口子； 冶金厂的大门。 组成：冶金有九里一塘。 新风里-我住了近二十年的社区，老房子已被拆除，新的安置房还没有要兴建的意思； 勤俭里-原冶金中学，现聋哑学校旁边，我家现在租住的地方； 文明里-龙家坪菜市场铁路洞口的左手边，我外婆目前住的地方； 望江里-龙家坪菜市场的旁边； 建国里-冶金医院的旁边，在小时候的我看来很多家庭条件优越的同学住在那边，房子看上去也新一些，不过现在其中的很多人都搬去了河边的湘水明珠； 友爱里-原冶金商店后的那一块，房子比较老，很多老师住在那一块，我的英语启蒙便是在友爱里一个老师家完成的，老师好像是西安交大的硕士，教完我们后在南华教书。 龙山里-冶金幼儿园对面，房子很新； 怀窑里-冶金招待所的右手边，我的小学班主任住在这里； 互助里-冶金球坪那一块，这是我印象中存在感最低的一个社区了； 八角塘-冶金球坪跟冶金厂中间的那一块，冶金离退办设在此处，我奶奶在那里领抚恤金。 图集:还是图片比较有说服力。 冶金花园进门，人工池塘已经被放空准备重建，里面的两只鹿雕像破败不堪，令人唏嘘不已。 鹿雕旁假山中的一个人工泉眼，现已枯竭。小时候在一些玄幻的影视作品中得到的灵感，让我每次到这里时思绪都会天马行空。那时网吧、游戏厅还未大行其道，许多在此结伴游玩的小朋友亦会掬一捧“泉水”解渴。 满目苍夷。 穿过花园中的树林小道，来到另一个人工池塘，照片的左侧还在我小学四五年级时建了一座拱桥。图中最高的假山，小时候的我曾数次登顶。 园中的土包亦被改建，早年的时候只有漫坡杂草。 冶金老年人的门球场。何伟在“中国三部曲”的《江城》一书中亦有描写这种运动，门球场设在涪陵师专内何伟居住的宿舍楼下。 这一块是早年间冶金花园与儿童游乐园的分界处。 早年这这条铁蜈蚣其实是设在冶金花园里的，小学期间改建时搬到了此处，儿时的影集里似乎还能找到其身影。 叫不出名字的娱乐设施，早年也摆在花园侧，上小学前奶奶带着我来这里玩时，我总会在里面钻来钻去，自有其乐趣。 园中地标，大象滑梯。 滑梯顶部鸟瞰。 滑梯正面，长鼻，象牙，栩栩如生。 也是早年摆在花园侧的一个娱乐设施，形似蜗牛。 早期改建前这里有一个电动游乐设施，大概是围着中轴转的飞船，后被拆除，现在是篮球场。 游乐园正门。 我就读的小学，学校中心的女孩雕像历经数年风雨，仍雪白如新。 冶金球坪，难得的空地。 冶金俱乐部，小学开学典礼和期末典礼必在此看电影。 冶金体育馆。 体育馆与俱乐部间的歌舞厅。 体育馆正门，内设羽毛球馆、乒乓球台和桌球台。 冶金钓鱼台，著名的小吃集散地，现如今小吃商贩们被禁止在此摆摊设点，钓鱼台的中心被一只巨大的齿轮钱币雕像取代，冶金钓鱼台的烧烤摊们何去何从。 曾经的冶金中学，《致青春》中朱小北的扮演者刘雅瑟即毕业于此，现已改建为聋哑学校（特殊教育学校）。 我住了二十年的老房子曾坐落于此，现已被夷为平地。 百感交集。 冶金技校，与冶金小学相邻。 龙家坪菜市场，冶金人重要的生活场所。]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用指令速查表]]></title>
    <url>%2F2017%2F03%2F27%2FGit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[对于IT从业人员来说Git的重要性不言而喻，前几天尝试百度前端学院的作业，发现是提交到Github上供导师审阅，遂产生了学习Git的想法。参考网上现有的教程，发现廖雪峰老师的Git教程是相对较为系统和详细的，所以跟着教程一步一步走即可（感谢互联网，想学的东西几乎没有找不到的）。为了方便，将教程中提到的指令集中整理到这里，方便以后查阅。另外还有一些内容是自己对于一些知识的理解，学习过程中遇到的问题以及从网上找到的相应解决方案，也一并总结到这里。 Cheat Sheet 指令 用途 $ mkdir YourFolderName 创建目录 $ cd YourFolderName 进入目录 $ pwd 查看当前目录 $ git init 将当前目录变成Git可以管理的仓库 $ git add YourFileName.format 将文件添加到仓库（此时文件处于暂存区） $ git commit -m &quot;Description&quot; 将文件提交到仓库（此时文件处于版本库） $ git add file1name.format $ git add file2name.format file3name.format $ git commit -m &quot;add 3 files&quot; 向版本库中提交多个文件（多次add一次commit） $ git status 查看仓库当前状态（有无文件改动、有无未向版本库提交的文件） $ git diff 查看改动 $ git add YourFileName.format 修改文件后将其添加到仓库准备提交 $ git commit -m &quot;Description&quot; 修改文件后提交 $ git log 查看历史记录 $ git log --pretty=oneline 查看历史记录（显示在一行） $ git reset --hard HEAD^ 将文件回退到上个版本 $ git reset --hard HEAD^^ 将文件回退到上上个版本 $ git reset --hard HEAD~n 将文件回退到上n个版本 $ git reset --hard ******* 将文件回退到指定版本（星号内为[master **]中的星号） $ git reflog 查看历史提交的commit id $ cat YourFileName.format 查看文件内容 $ git diff HEAD -- YourFileName.format 查看工作区和版本库里面最新版本的区别 $ git checkout -- YourFileName.format 丢弃工作区的修改 $ git reset HEAD YourFileName.format 丢弃已添加到仓库的修改 $ rm YourFileName.format 删除工作区中的文件 $ git rm YourFileName.format 删除版本库中的文件（完整删除需要再$ git commit -m “Description”以提交） $ git checkout -- YourFileName.format 从版本库中恢复误删的文件（只能是最新版） $ git remote add origin https://github.com/YourGithubID/YourRepositoryName.git -将本地库与Github上建立的远程库关联起来 $ git push -u origin master 将本地库的所有内容推送到远程库 $ git push origin master 每次本地提交后若有必要即可用此命令推送最新修改到远程库 $ git push origin BranchName 推送其他分支到远程库 $ git clone https://github.com/GithubID/RepositoryName.git 将远程库克隆下来成为本地库（需要仓库地址） $ git checkout -b BranchName 创建并切换分支（一步到位） $ git branch BranchName 创建分支 $ git checkout BranchName 切换分支 $ git branch 查看分支 $ git merge BranchName 合并分支 $ git branch -d BranchName 删除分支 $ git push origin :BranchName 删除远程库中的分支 $ git log --graph --pretty=oneline --abbrev-commit 查看分支的合并情况（可视化） $ git remote rm origin $ git remote add origin git@github.com:GithubID/RepositoryName.git $ git push -u origin master 将添加远程库时使用的HTTPS方式删除然后重新设置成ssh方式（不用每次push到远程库都输入用户名和密码） $ git merge --no-ff -m &quot;Description&quot; dev 强制禁用’Fast forward’模式并在merge时生成一个新的commit（分支历史中可以看出分支信息） $ git stash 当需要去其他分支工作（如修改bug）时，将当前工作现场保存起来（即git add YourFileName.format后不提交以保存现场） $ git stash list 查看当前已保存的工作现场 $ git stash apply 恢复现场（不删除stash内容） $ git stash drop 删除stash内容 $ git stash pop 恢复现场并删除stash内容 $ git stash apply stash@{0} 恢复指定的stash内容（stash命令可保存多次工作现场） $ git branch -D BranchName 强制删除分支（分支未被合并） $ git fetch 从远程获取最新版本到本地，不会自动merge $ git pull 从远程获取最新版本并merge到本地（相当于先’git fetch’再’git merge’） $ git branch --set-upstream BranchName origin/BranchName 一般用在’git pull’后把本地分支与远程库中的分支对应起来 $ git checkout -b BranchName origin/BranchName 在本地创建和远程分支对应的分支（本地和远程分支的名称最好一致） $ git tag TagName 给当前分支的最新版本commit打上标签 $ git tag 查看当前分支的所有标签 $ git tag TagName CommitID 给某非最新版本的commit打上标签 $ git show TagName 查看标签对应commit的具体信息 $ git tag -a TagName -m &quot;Description&quot; CommitID 给某个commit打上标签的同时添加描述（推荐） $ git tag -s TagName -m &quot;Description&quot; CommitID 用私钥（PGP签名）给某个commit打上标签的同时添加描述（推荐）（用到再学） $ git tag -d TagName 删除某个标签 $ git push origin TagName 将某个标签对应的commit推送到远程库中 $ git push origin --tags 一次性向远程库中推送所有未推送到远程的本地标签 $ git tag -d TagName$ git push origin :refs/tags/TagName 删除已推送到远程库中的标签 $ git config --global color.ui true 让Git显示颜色使命令输出看起来更醒目 $ git add -f YourFileName.format 将通过.gitignore忽略的特殊文件强制添加到Git $ git check-ignore -v YourFileName.format 找出哪个规则导致文件无法上传到Git $ git config --global alias.YourAbbreviation GitCommand 将给某条git命令(GitCommand)配置简写(YourAbbreviation) $ cat .git/config 查看每个仓库的配置文件信息 $ cat .gitconfig 查看当前用户的Git配置文件信息 理解Git工作区、版本库、暂存区间的关系 工作区，就是电脑上存文件的目录； 版本库，就是当前被管理仓库中的一个隐藏目录.git，内部含有暂存区stage、Git为我们自动创建的第一个分支master以及一个指向分支master的指针HEAD; 暂存区，就是版本库中的stage，新建的文件和改动过的文件，先存在暂存区中，再提交到分支中。三者的关系如图一所示。图一当新添加了文件或新修改了文件，先使用$ git add YourFileName.format命令将文件添加到暂存区stage，此时版本库的状态如图二所示。图二再使用$ git commit -m &quot;Description&quot;提交到当前分支，之后暂存区中便没有任何内容，版本库状态如图三所示。图三 理解$ git checkout -- YourFileName.format与$ git reset HEAD YourFileName.format两条命令的区别当文件1.0被修改为文件1.1，但还未通过$ git add YourFileName.format命令添加到暂存区时，可以通过$ git checkout -- YourFileName.format命令将工作区内的修改丢弃掉；当文件1.0被修改为文件1.1，且已通过$ git add YourFileName.format命令添加到暂存区时，$ git reset HEAD YourFileName.format命令可将已添加到暂存区中的修改丢弃，之后可通过$ git checkout -- YourFileName.format命令将工作区中的修改丢弃。 关于删除文件$ rm YourFileName.format命令删除的是工作区中的文件，可通过$ git checkout -- YourFileName.format命令找回；$ git rm YourFileName.format命令删除的是版本库（当前分支）中的文件，不可通过通过$ git checkout -- YourFileName.format命令找回。 疑惑：将本地库所有内容推送到远程库的命令$ git push -u origin master中参数-u的含义？占坑待填。 分支的合并与创建HEAD是一个指针，其作用可类比PC桌面的程序快捷方式。没有创建其他分支时，仅有一个主分支master，HEAD指向当前分支，即主分支，master再指向每次提交，每提交一次，master分支前移一步。当创建了其他分支时，HEAD便可以指向其他分支，表明当前分支为其他分支。新建分支的本质其实还是创建一个可以动的新指针。如，我们新建一个名为dev的指针，与当前的master指向同一个提交，再把HEAD指针指向dev，当前分支就变成了dev。创建分支仅仅是新建了一个指针，因此速度很快，工作区文件并没有发生变化。在这之后，我们每次对工作区的修改和提交都在dev分支上，每重新提交一次，dev指针前移一步，master指针则保持不变。dev上的工作完成以后，就可以把dev合并到master上，本质上是把master指针指向dev指针当前所指向的提交。合并分支结束后可以选择删除dev分支，即删除dev指针。删除后，仅剩下一条master分支。 疑惑：Fast forward、快进模式、合并模式？解答：Git一般有三种合并方式，--no-ff、--squash和fast-forward（默认），可用下图表示。 fast-forward方式，指当条件允许时，直接把HEAD指针指向合并分支的头来完成合并，如果删除分支，由于整个过程中没有创建commit，分支信息将会丢失。 --squash方式，可以对一些不必要的commit进行压缩，如某一分支在开发过程中有数个commit，显得非常杂乱，合并时并不希望把这些commit带进master分支，因此用--squash命令可以先将commit进行合并，但不移动HEAD指针，不提交。最后再提交一次进行总结，完成最终合并。 --no-ff指强制关闭Fast forward方式，每次合并会创建commit，删除分支后分支信息不会丢失，能看出曾经做过哪些合并。具体过程如下图所示。一般的master分支非常稳定，仅用来发布新版本，不进行开发。通常都是新开一个开发分支（dev）进行开发，待到要发布时，再将开发分支合并到master分支上。因此Git分支功能在团队协作中非常强大。 本地分支需不需要往远程推送的参考 master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 团队协作中分支的问题多人协作中，大家往master与dev分支中推送各自的修改，通过$ git clone https://github.com/GithubID/RepositoryName.git命令将远程库克隆到本地时，默认情况下只能看到本地的master分支（即使用$ git branch命令查看分支时只有master分支）。进行开发修改时，需自行创建一个dev分支进行修改，同时时不时将修改推送到远程（$ git commit -m &quot;Description&quot;、$ git push origin dev）。当你的提交与团队中的其他开发者的提交发生冲突时，可用git pull将最新的提交从远程库的dev分支中抓取下来，在本地合并，解决冲突，再提交。$ git pull有可能不成功，原因是未设置本地dev分支与远程库中dev分支（origin/dev）的对应，此时运行命令$ git branch --set-upstream dev origin/dev即可。之后再逐步解决冲突、提交。多人协作的工作模式通常是这样： 首先，可以尝试用$ git push origin BranchName推送自己的修改； 如果推送失败，则是因为远程分支比你本地的版本更加新，需要先用$ git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用$ git push origin BranchName推送就能成功。 如果$ git pull提示“no tracking information”，则说明本地分支和远程分支的对应关系没有创建，可通过运行命令$ git branch --set-upstream BranchName origin/BranchName解决。 标签管理发布一个版本时，通常先在版本库中打一个标签（tag），这样就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。标签实质上是指向某个commit的指针，看上去像分支，但分支可以移动，标签不可，且标签的创建和删除都在一瞬间完成。之前我们提到过，要回滚到某个历史版本时，需要那次commit ID（可由命令$ git reflog得到），但通过commit ID寻找历史版本的缺点显而易见，容易搞混淆。因此tag的目的是给历史版本的commit一个容易记住的、有意义的名字。 在github上参与开源项目先将项目fork到自己帐号下，再clone到本地修改、推送（注意，只能从自己的帐号下推送）。参与开源的过程可通过下图表示。 先将开源项目fork到自己的帐号下，然后克隆到本地（在GitHub上，可以任意Fork开源仓库）； 做出修改（如修复bug、新增功能）后，推送到自己账号下对应的仓库中（自己拥有Fork后的仓库的读写权限）； 再在github上发起一个pull request，等待接受（可以推送pull request给官方仓库来贡献代码）。 忽略特殊文件有些时候必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件等等，每次git status都会显示Untracked files…在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 一些Git命令简写的参考 $ git config --global alias.st status $ git config --global alias.co checkout $ git config --global alias.ci commit $ git config --global alias.br branch $ git config --global alias.unstage &#39;reset HEAD&#39;-输入命令$ git unstage YourFileName.format时，等同于$ git reset HEAD git reset HEAD test.py $ git config --global alias.last &#39;log -1&#39; $ git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot; Git配置文件配置Git的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。12345678910111213141516$ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[remote &quot;origin&quot;] url = git@github.com:michaelliao/learngit.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master[alias] last = log -1 简写就在alias后面，要删除别名，直接把对应的行删掉即可。而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中：123456789$ cat .gitconfig[alias] co = checkout ci = commit br = branch st = status[user] name = Your Name email = your@email.com 配置简写也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。 搭建Git服务器先占个坑备忘，以后用到再研究。]]></content>
      <categories>
        <category>Git学习笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近况]]></title>
    <url>%2F2017%2F03%2F20%2F%E8%BF%91%E5%86%B5%2F</url>
    <content type="text"><![CDATA[最近忙着求职、毕业，都快忘了这一小块自留地了。深刻地理解了一位前辈说过的话：找工作本身就是一份工作。三月初陪舅舅去九寨沟玩了一趟，算是在四川去过的第一个旅游景点（如果锦里、宽窄巷子这种不算的话）。住的是喜来登，团费确实便宜，若不是通过旅行社渠道，那点团费可能付酒店房费和三顿buffet都不够。不过舅舅在国外呆久了，感觉心也单纯了很多，导游联合当地人铺设的一些圈套也上了那么几个，花了一点小钱。恐怕导游最不喜欢的就是我这种除了团费一分钱都不会出的人吧，哈哈。未来的规划方面，当前还是打算找个专业对口的工作干几年，等符合条件后争取肉身翻墙吧。在舅舅回国跟他玩的这段时间里这个想法也越发坚定了，有的人说出去是到别人国家当二等公民，但好像现在我好像也没享受到什么一等公民的好处？技术方面，说好的把JavaScript高程刷一遍也还没来得及，Angular2搭建好了环境还没来得及深入，等以后工作了再挤时间慢慢折腾吧。另外一点收获是在写下这篇文章之前终于搭建好了Android的开发环境，也解决了导入别人项目时IDE（暂时用的是Intellij IDEA）报一大堆错的情况，真机测试条件也有了，美中不足的是电脑太慢，IDE用起来很卡，可能也有一部分是GFW的原因。所以按照自己计划的技术栈，还要学一下Java。另外计算机专业的必修课有空了也要过一遍，像数据结构，编译原理和算法之类的。游戏最近很少玩了，不过比赛跟直播倒是没少看。等以后工作了，可能也会保持这样的状态，没什么机会玩，看一看就好。暂时就写这么多吧，希望近期能找到一份理想的工作，然后一点一点朝着自己的目标靠近。]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window.onload的改进之绑定多条指令]]></title>
    <url>%2F2017%2F01%2F18%2Fwindow-onload%E7%9A%84%E6%94%B9%E8%BF%9B%E4%B9%8B%E7%BB%91%E5%AE%9A%E5%A4%9A%E6%9D%A1%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[window.onloadwindow.onload用于页面加载后处理一些事件，在页面加载后被立即触发，但每次只能为其绑定一个事件函数。 addLoadEvent()《JavaScript DOM编程艺术》一书中介绍了一个名为&quot;addLoadEvent&quot;的函数，用于共享onload事件，该函数由Simon Wilson 编写，只有一个参数：页面加载完成时需要执行的函数名称。函数具体操作如下： 把现有的window.onload事件处理函数的值存入变量oldonload中； 如果这个处理函数还没绑定任何函数，就把新函数添加给它； 如果这个处理函数已经绑定了一些函数，就把新函数添加到现有指令的末尾。 具体代码如下：1234567891011function addLoadEvent(func) &#123; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = func; &#125; else &#123; window.onload = function() &#123; oldonload(); func(); &#125; &#125; &#125; 这样就为需要在页面加载后执行的函数们创建了一个队列，具体的使用如下（前面已声明函数）：12addLoadEvent(Function1);addLoadEvent(Function2); 无论我们需要在页面加载后执行多少个函数，只需要在后面添加一条语句即可。 与jQuery中$(document).ready()方法的对比学过jQuery的朋友肯定知道$(document).ready()，可能会觉得上面提到的方法跟$(document).ready()十分类似，但实际上还是存在一定的差异： addLoadEvent() $(document).ready() 执行时机 网页中所有内容执行完之后（包括图片） 网页的DOM结构加载完成之后（此时图片等与元素相关联的东西可能并没有加载完） 编写个数 可以同时编写多个 可以同时编写多个 简化写法 无 $(document).ready(function{})可以写成$(function(){}) 以上表格参考自《锋利的jQuery》。]]></content>
      <categories>
        <category>JavaScript学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于本站]]></title>
    <url>%2F2017%2F01%2F17%2F%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99%2F</url>
    <content type="text"><![CDATA[本站是基于github pages与hexo搭建个人博客的一次尝试，感觉挺好用的，希望以后能把这里当成一个管理知识的地方好好利用起来。看来有必要先学习一下Markdown了。]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>github pages</tag>
        <tag>hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
